# cbk --- 命令行备份管理工具

[TOC]

------

## 项目介绍

**CBk**（Command Line Backup）是一款高效、便捷的命令行备份管理工具，旨在帮助用户通过简洁的命令行操作，轻松管理多个备份任务，实现数据的快速备份、查询、恢复等功能，同时确保各备份任务之间的相互隔离，保障数据的安全性和独立性。它适用于各种需要定期备份数据的场景，无论是个人开发者管理代码项目，还是企业运维人员维护关键业务数据，都能提供有力支持。

# 命令设计

## 列出项目列表

```bash
cbk list
cbk l
```

> **输出格式**

```bash
ID  任务名    目标目录            备份目录            保留数量  
---------------------------------------------------------------
1   project1  /path/to/source1   /path/to/destination1  5       
2   project2  /path/to/source2   /path/to/destination2  3        
3   project3  /path/to/source3   /path/to/destination3  2      
```

- **说明**：以表格形式清晰展示所有备份任务的基本信息，包括任务的唯一标识ID、任务名称、目标目录（需要备份的数据所在路径）、备份目录（备份文件存放路径）以及保留的备份版本数量，方便用户快速了解当前所有备份任务的概况。

## 执行备份任务

```bash
cbk run [任务名|任务ID]
cbk r [任务名|任务ID]
```

- **说明**：用户可以通过指定任务的名称或ID来执行对应的备份任务，工具将根据任务配置自动完成数据的备份操作，并生成相应的备份文件，同时记录备份过程中的相关信息，如备份时间、备份状态等。

## 添加备份任务

```bash
cbk a -n 任务名 -t /path/to/target -b /path/to/backup -k 1
cbk add -name 任务名 --target /path/to/target --backup /path/to/backup --keep 1
```

- **说明**：提供两种命令格式供用户选择，方便用户根据自己的习惯快速添加新的备份任务。用户需要指定任务的名称、目标目录、备份目录以及希望保留的备份版本数量，工具将根据这些信息创建新的备份任务，并将其添加到任务列表中。

## 删除备份任务

```bash
cbk delete -name 任务名
cbk d -n 任务名
cbk delete -id 任务id
```

- **说明**：用户可以通过任务的名称或ID来指定需要删除的备份任务，工具将从任务列表中移除该任务，并清理与该任务相关的配置信息。但需要注意的是，此操作不会自动删除已经生成的备份文件，用户需要手动清理，以避免数据误删除。

## 编辑备份任务

```bash
# 简短
cbk e -n 任务名 -t /path/to/target -b /path/to/backup -k 1
# 长标志
cbk edit -name 任务名 --target /path/to/target --backup /path/to/backup --keep 1
```

- **说明**：用户可以对已存在的备份任务进行编辑，修改任务的目标目录、备份目录或保留的备份版本数量等信息。用户需要指定任务的名称，并提供需要修改的新信息，工具将根据这些信息更新任务的配置。

## 查看备份日志

```bash
# 查看所有日志
cbk log

# 查看指定
cbk log -n 任务名
cbk log -id 任务id
```

- **说明**：用户可以通过`cbk log`命令查看所有备份任务的备份日志，也可以通过指定任务的名称或ID来查看特定任务的备份日志。备份日志包括以下关键信息：

| 时间戳              | 任务ID | 任务名   | 备份状态 | 备份文件名                       | 备份大小 | 备份路径              | 哈希缩写 |
| ------------------- | ------ | -------- | -------- | -------------------------------- | -------- | --------------------- | -------- |
| 2025-03-26 14:36:00 | 1      | project1 | true     | project1_backup_20250326.tar.gz  | 2.5 GB   | /path/to/destination1 | 1a2b3c   |
| 2025-03-26 15:02:00 | 2      | project2 | false    | -                                | -        | -                     | -        |
| 2025-03-26 16:00:00 | 3      | project3 | true     | project3_backup_20250326.tar.bz2 | 1.8 GB   | /path/to/destination3 | 4d5e6f   |

```
  时间戳            任务ID   任务名     备份状态    备份文件名                      备份大小       备份路径             哈希缩写 
-----------------------------------------------------------------------------------------------------------------------------
2025-03-26 14:36:00  1     project1   true      project1_backup_20250326.tar.gz   2.5 GB    /path/to/destination1   1a2b3c  
2025-03-26 15:02:00  2     project2   false     -                                 -         -                       -      
2025-03-26 16:00:00  3     project3   true      project3_backup_20250326.tar.bz   21.8 GB   /path/to/destination3   4d5e6f
```

- **时间戳**：备份完成的具体时间，格式统一为`YYYY-MM-DD HH:MM:SS`，便于用户快速了解备份操作的时间点。
- **任务ID**：任务的唯一标识，便于用户追踪和管理备份任务。
- **任务名**：任务的名称，应简洁明了，便于用户识别和记忆。
- **备份状态**：备份操作的成功与否，使用“成功”或“失败”等简短的单词表示，方便用户快速识别备份结果。
- **备份文件名**：生成的备份文件的名称，如果备份失败则显示“-”，表示没有生成备份文件。
- **备份大小**：备份文件的大小，单位可以是KB、MB、GB等，如果备份失败则显示“-”，表示没有生成备份文件，也就没有备份大小。
- **备份路径**：存放备份文件的路径，如果备份失败则显示“-”，表示没有生成备份文件，也就没有备份路径。
- **哈希缩写**：备份文件的哈希值后6位缩写，用于快速验证备份文件的完整性，如果备份失败则显示“-”。

## 查看指定备份任务的信息

```bash
cbk show -name 任务名
cbk s -n 任务名
cbk show -id 任务id
```

> 查看时输出的格式

```bash
ID  任务名      版本ID  版本哈希后6位
-------------------------------------
1   project1   3       1a2b3c
1   project1   5       4d5e6f
```

- **说明**：用户可以通过任务的名称或ID来查看指定备份任务的详细信息，包括任务的版本ID和对应版本的哈希值后6位缩写，帮助用户快速了解该任务的备份版本情况，便于进行版本管理和数据恢复操作。

## 解压备份任务|回滚备份任务

```bash
cbk unpack -name 任务名 --version 指定解压的版本 --output 指定输出的路径 --force 表示强制覆盖
cbk u -n 任务名 -v 指定解压版本 -o 指定输出的路径 -f 表示强制覆盖
cbk u -id 任务id -v 指定解压版本 -o 指定输出的路径 -f 表示强制覆盖
```

- **说明**：用户可以通过指定任务的名称或ID、需要解压的版本号、输出路径以及是否强制覆盖来执行备份文件的解压操作，实现数据的恢复。如果指定强制覆盖，工具将自动覆盖输出路径下已存在的同名文件或目录，否则会提示用户是否覆盖。

# 数据库表单设计

## 存储数据库选择

选择轻量级且易于部署和使用的SQLite数据库来存储备份任务的相关信息和备份记录，便于工具的跨平台使用和数据的本地管理。

## 数据操作层选择

采用GORM作为数据操作层，它提供了简洁易用的API，能够方便地实现与SQLite数据库的交互，提高开发效率，同时保证数据操作的准确性和可靠性。

## 备份记录表

| 字段名称         | 数据类型 | 是否主键 | 是否外键 | 描述               |
| :--------------- | :------- | :------- | :------- | :----------------- |
| version_id       | Integer  | 是       | 否       | 唯一标识备份版本   |
| task_id          | Integer  | 否       | 是       | 对应备份任务的ID   |
| timestamp        | String   | 否       | 否       | 备份完成的时间     |
| task_name        | String   | 否       | 否       | 备份任务的名称     |
| backup_status    | String   | 否       | 否       | 备份操作的成功与否 |
| backup_file_name | String   | 否       | 否       | 生成的备份文件名   |
| backup_size      | String   | 否       | 否       | 备份文件的大小     |
| backup_path      | String   | 否       | 否       | 存放备份文件的路径 |
| version_hash     | String   | 否       | 否       | 备份文件的哈希值   |

- **说明**：该表用于存储每次备份操作的详细记录，通过`version_id`唯一标识每个备份版本，`task_id`作为外键关联到备份任务表，其他字段分别记录备份操作的关键信息，便于用户查询和管理备份记录。

## 记录备份任务表

| 字段名称         | 数据类型 | 是否主键 | 是否外键 | 描述                   |
| :--------------- | :------- | :------- | :------- | :--------------------- |
| task_id          | Integer  | 是       | 否       | 唯一标识备份任务       |
| task_name        | String   | 否       | 否       | 备份任务的名称         |
| target_directory | String   | 否       | 否       | 需要备份的数据所在路径 |
| backup_directory | String   | 否       | 否       | 备份文件存放路径       |
| retention_count  | Integer  | 否       | 否       | 保留的备份版本数量     |

- **说明**：该表用于存储备份任务的基本信息，通过`task_id`唯一标识每个备份任务，其他字段分别记录任务的名称、目标目录、备份目录和保留的备份版本数量等关键信息，为备份操作提供配置依据。

## 结构体实现

```go
package main

import (
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"time"
)

// 备份记录表
type BackupRecord struct {
	VersionID   int       `gorm:"primaryKey;column:version_id"` // 版本ID，主键
	TaskID      int       `gorm:"foreignKey:TaskID;column:task_id"` // 任务ID，外键
	Timestamp   time.Time `gorm:"column:timestamp"` // 时间戳
	TaskName    string    `gorm:"column:task_name"` // 任务名
	BackupStatus bool     `gorm:"column:backup_status"` // 备份状态
	BackupFileName string  `gorm:"column:backup_file_name"` // 备份文件名
	BackupSize   string    `gorm:"column:backup_size"` // 备份大小
	BackupPath   string    `gorm:"column:backup_path"` // 备份路径
	VersionHash  string    `gorm:"column:version_hash"` // 版本hash
}

// 存储备份任务表
type BackupTask struct {
	TaskID       int    `gorm:"primaryKey;autoIncrement;column:task_id"` // 任务ID，主键，自动增长
	TaskName     string `gorm:"column:task_name"` // 任务名
	TargetDir    string `gorm:"column:target_dir"` // 目标目录
	BackupDir    string `gorm:"column:backup_dir"` // 备份目录
	RetainCount  int    `gorm:"default:3;column:retain_count"` // 保留数量，默认值为 3
}

func main() {
	// 连接 SQLite 数据库
	db, err := gorm.Open(sqlite.Open("backup.db"), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	// 自动迁移表结构
	db.AutoMigrate(&BackupRecord{}, &BackupTask{})
}
```

## SQL建表语句

```sql
-- 创建备份记录表，用于存储每次备份任务的详细记录
CREATE TABLE IF NOT EXISTS backup_records (
    version_id TEXT PRIMARY KEY, -- 唯一标识每次备份的版本号
    task_id INTEGER, -- 关联的备份任务 ID
    timestamp TEXT, -- 备份任务的时间戳
    task_name TEXT, -- 备份任务的名称
    backup_status TEXT, -- 备份任务的状态（例如成功、失败等）
    backup_file_name TEXT, -- 生成的备份文件名称
    backup_size TEXT, -- 备份文件的大小
    backup_path TEXT, -- 备份文件的存储路径
    version_hash TEXT, -- 备份版本的哈希值，用于校验
    FOREIGN KEY (task_id) REFERENCES backup_tasks (task_id) ON DELETE CASCADE -- 定义外键关系，删除备份任务时自动删除相关备份记录
);

-- 创建备份任务表，用于定义备份任务的基本信息
CREATE TABLE IF NOT EXISTS backup_tasks (
    task_id INTEGER PRIMARY KEY AUTOINCREMENT, -- 唯一标识备份任务的 ID （自动递增）
    task_name TEXT, -- 备份任务的名称
    target_directory TEXT, -- 需要备份的目标目录
    backup_directory TEXT, -- 备份文件存放的目标目录
    retention_count INTEGER -- 保留的备份版本数量
);
```

# 工具函数

## 版本ID生成函数

```go
package main

import (
	"fmt"
	"math/rand"
	"strings"
	"time"
)

const charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

// 全局随机数生成器
var globalRand = rand.New(rand.NewSource(time.Now().UnixNano()))

// generateID 生成包含时间戳和指定长度随机字符的ID
func generateID(randomLength int) string {
	if randomLength < 0 {
		return "" // 如果随机部分长度为负数，返回空字符串
	}

	// 获取当前时间的纳秒级时间戳
	timestamp := time.Now().UnixNano()

	// 使用strings.Builder进行字符串拼接
	var builder strings.Builder

	// 将时间戳转换为字符串并拼接到builder中
	builder.WriteString(fmt.Sprintf("%d", timestamp))

	// 预先分配足够的内存
	randomPart := make([]byte, randomLength)
	for i := 0; i < randomLength; i++ {
		randomPart[i] = charset[globalRand.Intn(len(charset))]
	}

	// 将随机字符部分拼接到builder中
	builder.Write(randomPart)

	// 返回最终拼接的字符串
	return builder.String()
}

func main() {
	// 示例：生成时间戳后附加长度为16的随机字符的ID
	id := generateID(16)
	fmt.Println("Generated ID:", id)
}
```

# go文件设计

## 命令文件设计

1. 创建 `commands.go` 文件

在这个文件中，我们将定义所有子命令及其参数。

```go
// commands.go
package main

import (
	"flag"
	"fmt"
)

// 定义子命令及其参数
func DefineCommands() {
	// 子命令：list
	listCmd := flag.NewFlagSet("list", flag.ExitOnError)
	listShortCmd := flag.NewFlagSet("l", flag.ExitOnError)

	// 子命令：run
	runCmd := flag.NewFlagSet("run", flag.ExitOnError)
	runShortCmd := flag.NewFlagSet("r", flag.ExitOnError)
	runNameOrID := runCmd.String("name", "", "任务名或任务ID")

	// 子命令：add
	addCmd := flag.NewFlagSet("add", flag.ExitOnError)
	addShortCmd := flag.NewFlagSet("a", flag.ExitOnError)
	addName := addCmd.String("name", "", "任务名")
	addTarget := addCmd.String("target", "", "目标目录")
	addBackup := addCmd.String("backup", "", "备份目录")
	addKeep := addCmd.Int("keep", 0, "保留数量")

	// 子命令：delete
	deleteCmd := flag.NewFlagSet("delete", flag.ExitOnError)
	deleteShortCmd := flag.NewFlagSet("d", flag.ExitOnError)
	deleteName := deleteCmd.String("name", "", "任务名")
	deleteID := deleteCmd.Int("id", 0, "任务ID")

	// 子命令：edit
	editCmd := flag.NewFlagSet("edit", flag.ExitOnError)
	editShortCmd := flag.NewFlagSet("e", flag.ExitOnError)
	editName := editCmd.String("name", "", "任务名")
	editTarget := editCmd.String("target", "", "目标目录")
	editBackup := editCmd.String("backup", "", "备份目录")
	editKeep := editCmd.Int("keep", 0, "保留数量")

	// 子命令：log
	logCmd := flag.NewFlagSet("log", flag.ExitOnError)
	logName := logCmd.String("name", "", "任务名")
	logID := logCmd.Int("id", 0, "任务ID")

	// 子命令：show
	showCmd := flag.NewFlagSet("show", flag.ExitOnError)
	showShortCmd := flag.NewFlagSet("s", flag.ExitOnError)
	showName := showCmd.String("name", "", "任务名")
	showID := showCmd.Int("id", 0, "任务ID")

	// 子命令：unpack
	unpackCmd := flag.NewFlagSet("unpack", flag.ExitOnError)
	unpackShortCmd := flag.NewFlagSet("u", flag.ExitOnError)
	unpackName := unpackCmd.String("name", "", "任务名")
	unpackID := unpackCmd.Int("id", 0, "任务ID")
	unpackVersion := unpackCmd.String("version", "", "指定解压的版本")
	unpackOutput := unpackCmd.String("output", "", "指定输出的路径")
	unpackForce := unpackCmd.Bool("force", false, "表示强制覆盖")

	// 子命令：version
	versionCmd := flag.NewFlagSet("version", flag.ExitOnError)

	// 子命令：help
	helpCmd := flag.NewFlagSet("help", flag.ExitOnError)
}

// 定义子命令的执行逻辑
func ExecuteCommands(args []string) {
	switch args[0] {
	case "list":
		fmt.Println("列出项目列表")
	case "l":
		fmt.Println("列出项目列表")
	case "run":
		fmt.Printf("执行备份任务: %s\n", args[1])
	case "r":
		fmt.Printf("执行备份任务: %s\n", args[1])
	case "add":
		fmt.Printf("添加备份任务: %s, %s, %s, %s\n", args[1], args[2], args[3], args[4])
	case "a":
		fmt.Printf("添加备份任务: %s, %s, %s, %s\n", args[1], args[2], args[3], args[4])
	case "delete":
		fmt.Printf("删除备份任务: %s\n", args[1])
	case "d":
		fmt.Printf("删除备份任务: %s\n", args[1])
	case "edit":
		fmt.Printf("编辑备份任务: %s, %s, %s, %s\n", args[1], args[2], args[3], args[4])
	case "e":
		fmt.Printf("编辑备份任务: %s, %s, %s, %s\n", args[1], args[2], args[3], args[4])
	case "log":
		fmt.Printf("查看备份日志: %s\n", args[1])
	case "show":
		fmt.Printf("查看指定备份任务的信息: %s\n", args[1])
	case "s":
		fmt.Printf("查看指定备份任务的信息: %s\n", args[1])
	case "unpack":
		fmt.Printf("解压备份任务: %s, %s, %s, %s, %t\n", args[1], args[2], args[3], args[4], args[5])
	case "u":
		fmt.Printf("解压备份任务: %s, %s, %s, %s, %t\n", args[1], args[2], args[3], args[4], args[5])
	case "version":
		fmt.Println("版本信息")
	case "help":
		fmt.Println("帮助信息")
	default:
		fmt.Println("未知命令")
	}
}
```

**`commands.go` 文件**：

- 定义了所有子命令及其参数。
- 提供了 `DefineCommands` 函数用于初始化子命令及其参数。
- 提供了 `ExecuteCommands` 函数用于执行子命令的逻辑。

## 主main示例设计

2. 创建 `main.go` 文件

在主文件中，我们将导入 `commands.go` 文件并调用相关函数。

```go
// main.go
package main

import (
	"flag"
	"fmt"
	"os"
)

func main() {
	// 主标志
	vFlag := flag.Bool("v", false, "显示详细信息")
	vvFlag := flag.Bool("vv", false, "显示更详细的信息")
	hFlag := flag.Bool("h", false, "显示帮助信息")
	helpFlag := flag.Bool("help", false, "显示帮助信息")

	// 解析主标志
	flag.Parse()

	// 判断主标志
	if *vFlag {
		fmt.Println("显示详细信息")
		return
	}
	if *vvFlag {
		fmt.Println("显示更详细的信息")
		return
	}
	if *hFlag || *helpFlag {
		fmt.Println("显示帮助信息")
		return
	}

	// 定义子命令及其参数
	DefineCommands()

	// 判断子命令
	if len(os.Args) < 2 {
		fmt.Println("请输入有效的命令")
		return
	}
	ExecuteCommands(os.Args[1:])
}
```

**`main.go` 文件**：

- 定义了主标志 `-v`、`-vv`、`-h` 和 `--help`。
- 调用了 `DefineCommands` 函数来初始化子命令及其参数。
- 根据用户输入的命令调用 `ExecuteCommands` 函数来执行具体的逻辑